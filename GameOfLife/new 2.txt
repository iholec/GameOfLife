#include "stdafx.h"
#include "GOLField.h"
#include <string>
#include <iostream>

int GOLField::fast_mod(const int input, const int ceil)
{
	// apply the modulo operator only when needed
	// (i.e. when the input is greater than the ceiling)
	return input >= ceil ? input % ceil : input;
	// NB: the assumption here is that the numbers are positive
	return 0;
}

GOLField::GOLField(char * read_field, const int width, const int height)
{
	field_ = new char [(width * height) + 1];
	field_minus_one_ = new char [(width * height) + 1];
	width_ = width;
	len_ = width * height;//todo remove
	//todo maybe save whole len as well

	field_[width * height] = '\0';
	field_minus_one_[width * height] = '\0';

	std::memcpy(field_, read_field, (width * height) * sizeof(char)); //todo might be + 1 I guess
	std::memcpy(field_minus_one_, read_field, (width * height) * sizeof(char)); //todo might be + 1 I guess
}

char * GOLField::life(const int generations) const //todo improve, make 1D with  int array[width * height + 1]; int SetElement(int row, int col, int value){ array[width * row + col] = value};
{
	for(int gen = 0; gen < generations; ++gen)
	{
		for (int i = 0; i < len_ ; ++i)
		{
			int neighbors = 0;

			/*uint32_t test1 = (i - 1 + (width_ * height_)) % (width_ * height_);
			uint32_t test2 = (i - 1 + static_cast<uint64_t>(width_ * height_)) * static_cast<uint64_t>(width_ * height_) >> 32;
			uint32_t test3 = (i - 1 + (width_ * height_)) & (width_ * height_ - 1);
			*/
			if (field_minus_one_[fast_mod((i - 1 + len_), len_)] == 'x') // todo modulo not modulo cause modulo shit height_) % height_
			{
				++neighbors;
			}
			if (field_minus_one_[fast_mod((i + 1 + len_), len_)] == 'x')
			{
				++neighbors;
			}
			if (field_minus_one_[fast_mod((i - width_ + len_), len_)] == 'x') //todo how here modulo not modulo
			{
				++neighbors;
			}
			if (field_minus_one_[fast_mod((i + width_ + len_) , len_)] == 'x')
			{
				++neighbors;
			}
			if (field_minus_one_[fast_mod((i - width_ - 1 + len_) , len_)] == 'x')
			{
				++neighbors;
			}
			if (field_minus_one_[fast_mod((i + width_ + 1 + len_) , len_)] == 'x')
			{
				++neighbors;
			}
			if (field_minus_one_[fast_mod((i - width_ + 1 + len_) , len_)] == 'x')
			{
				++neighbors;
			}
			if (field_minus_one_[fast_mod((i + width_ - 1 + len_) , len_)] == 'x')
			{
				++neighbors;
			}

			if (field_minus_one_[i] == '.')
			{
				//Birth: A dead cell with exactly three live neighbors becomes a live cell.

				if (neighbors == 3)
				{
					field_[i] = 'x';
				}
			}
			else if (field_minus_one_[i] == 'x')
			{
				//Survival: A live cell with two or three live neighbors stays alive.
				//Death: A live cell with four or more neighbors dies from overpopulation, with one or none neighbors dies from isolation.
				//-> if not 2 or 3 then die
				if (!(neighbors == 3 || neighbors == 2))
				{
					field_[i] = '.';
				}
			}
		}

		std::memcpy(field_minus_one_, field_, len_ * sizeof(char));
	}
	return field_;
}

GOLField::~GOLField()
{
	delete[] field_;
	delete[] field_minus_one_;
}
